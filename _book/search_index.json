[
["index.html", "Build a Shiny Application from Scratch 1 Introduction 1.1 Getting Started 1.2 Components of a Shiny Application", " Build a Shiny Application from Scratch Hadrien@rstudio.com 1 Introduction Shiny is a powerful R package which allows you to create interactive web applications using the R programming language. It is particularly useful for creating applications that run on data and include some sort of data analysis or visualization. In addition to leveraging the power of R and its thousands of packages, one of the big benefits of shiny is the ease of developing applications using R only. Although it is possible to incorporate more traditional web design languages such as custom CSS or Javascript into your shiny application, it is not required. This online document was created to accompany workshops and webinars on how to build a Shiny application. This guide was created using the bookdown package and is still a work in progress. If you find any errors or typos you would like to correct, please feel free to submit a pull request on github. 1.1 Getting Started To get started, make sure you have the shiny package installed on your system. You can download shiny from CRAN using the command install.packages(&quot;shiny&quot;). The RStudio IDE contains a basic shiny application template you can use to create your first shiny application. To access this template, click on the new document icon in the top left corner of the IDE and select “Shiny Web App…”. This will create the R script file app.R which contains the basic components of a shiny application. You can use this simple shiny application as a starting point for building your own applications. It will look something like this: # # This is a Shiny web application. You can run the application by clicking # the &#39;Run App&#39; button in the RStudio IDE or running the command runApp(&quot;app.R&quot;). # library(shiny) # Define UI for application that draws a histogram ui &lt;- fluidPage( # Application title titlePanel(&quot;Old Faithful Geyser Data&quot;), # Sidebar with a slider input for number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) # Define server logic required to draw a histogram server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on input$bins from ui.R x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } # Run the application shinyApp(ui = ui, server = server) Don’t worry about how the application works exactly. We will go through each code chunk and explain what each one of them does in the next section. For now, try running the application on your computer by clicking the the “Run App” button in the RStudio IDE. This will start the application and open up your default web browser so you view it. 1.2 Components of a Shiny Application In this section, we’ll take a closer look at the shiny application code you just ran. Shiny applications are made up of 2 important components: the user interface (UI) and the server section. UI Section The UI section of your shiny application is where you define what your application will look like. In a nutshell, this is where you write your shiny functions and R code, which shiny will then take care of translating into html and CSS code that today’s modern web browsers can read and render into a beautiful web application. For example, the function shiny::fluidPage is often used in the UI section to define the outer most layer of the UI. It creates a web page containing both rows and columns which is fluid, meaning it scales to fill all available browser width. fluidpage() is R code, but once you initiate the rendering process from the console with the runApp() function or by clicking the “Run App” button in the RStudio IDE, it will get converted into HTML and CSS code that defines the layout of your application. Our example application used the default sidebarLayout function to create a webpage with a small sidebar on the left hand side, typically used for adding input controls, and a larger column on the right, usually reserved for displaying plots and other content. You can easily change this layout by replacing the sidebarLayout with other functions like fluidRow and tabsetPanel, for example. Shiny needs to know which section of your script is the UI vs. which section is the server, so make sure to save your UI code to the ui object. At the bottom of your script, you will need to pass both the ui and server objects you created to the function shiny::shinyApp(). Server Section The server section of your shiny application is where the computation takes place. Any code you write for transforming data or creating visualizations will most likely be in this section. "],
["user-interface.html", "2 User Interface 2.1 Layout Options 2.2 Input Controls", " 2 User Interface How your application will look will be determined by the ui object you define. This is where you will choose the layout of your application, the input controls available to the user, and the content that will be made visible. Let’s start with choosing a layout: 2.1 Layout Options At the time of this writing, you should always start with the fluidPage function as the outermost layer of your ui. This is the function you will use to pass important elements of your UI, such which layout type you’d like to use. Sidebar Layout One of the most commmon application layouts is theSidebar Layout, which has a skinny sidebar on the left hand-side (by default) where input controls are usually added and a main panel on the right-hand side which typically displays the results. To create this type of layout, simply pass the shiny ui function sidebarLayout to fluidPage. The sidebarLayout functions contains 2 required arguments, sidebarPanel and mainPanel, which are functions you can use to define the input controls for the sidebar and the output content you went to display in the main panel, respectively: # Minimum viable example of a shiny app with a sidebar layout library(shiny) # Define UI ui &lt;- fluidPage( # Sidebar Layout sidebarLayout( # Sidebar Layout Elements sidebarPanel = sidebarPanel(&quot;Replace this placeholder text with your input controls of choice.&quot;), mainPanel = mainPanel( &quot;Replace this placeholder text with outputs, defined in the server function below, you want displayed in the main panel.&quot; ) )) # Server function server &lt;- function(input, output) { } # Run the application shinyApp(ui = ui, server = server) This code generates the very boring looking application below. As you can see, it is made up of a small sidebar on the left and a main panel on the right: Grid Layout This type of layout gives you a bit more control of how to arrange your page. First, use the function fluidRow to add rows to your application and then the function column to create columns within those rows. These function allow you to create any grid layout you like, including even grids within grids. To create a page with 2 rows, 1 colum for the top half, and 2 columns for the bottom half, I would write the following code: # Minimum viable example of a shiny app with a grid layout library(shiny) # Define UI ui &lt;- fluidPage( # Grid Layout fluidRow(wellPanel(&quot;Top row&quot;)), fluidRow(column(width = 4, wellPanel(&quot;Bottom row, column 1, width 4&quot;)), column(width = 8, wellPanel(&quot;Bottom row, column 2, width 8&quot;)))) # Server function server &lt;- function(input, output) { } # Run the application shinyApp(ui = ui, server = server) Running the code generates the following shiny application: The first argument of the column function is width, which is based on the Bootstrap 12-wide grid system, so the total width for each row should add up to 12. We also used the function wellPanel to give our grid elements a grey background and a slightly inset border. This also gave us the ability to add text. Shiny has numerous “Panel” functions, which you can think as the elements you put inside the layout containers you created using the “Layout” functions like sidebarLayout, fluidrow, column, etc. 2.2 Input Controls An important part of creating the UI for you application is deciding what input controls, also referred to as control widgets, the users will have to interact with the application. Whatever value the application user chooses will be saved to a variable called input which you will use in the server section of your application. There are 13 standard control widgets from simple check boxes to sliders. To add a control widget to you shiny application, add the control widget function of your choice inside one of the *Panel functions. All widget control functions take at least 2 arguments: the inputID argument, which you will need to access the user input value in your code, and the label argument, where you can enter the description of the control widget visible to the user. With applications using a sidebar layout style, it is common to add widget controls in the sidePanel function, since it is better to reserver the bigger mainPanel for displaying plots. Below is an example of how you would add a searchable dropdown box to your shiny application using the widget control function selectInput: # Example of a shiny application with a sidebar layout and a selectInput control widget library(shiny) # Define UI ui &lt;- fluidPage( # Sidebar Layout sidebarLayout( # Sidebar Layout Elements (i.e. the panels) sidebarPanel = sidebarPanel( #Control Widget selectInput( inputId = &quot;input_1&quot;, label = &quot;Short description of control widget&quot;, choices = c( &quot;Iowa&quot; = &quot;IA&quot;, &quot;Colorado&quot; = &quot;CO&quot;, &quot;Massachusetts&quot; = &quot;MA&quot; ) ) ), mainPanel = mainPanel( &quot;Replace this placeholder text with outputs, defined in the server function below, you want displayed in the main panel.&quot; ) )) # Server function server &lt;- function(input, output) { } # Run the application shinyApp(ui = ui, server = server) Make a mental note of the inputID you choose for each of your control widgets, because this is how you will access the user input values in the server section of your application. "],
["server-function.html", "3 Server Function", " 3 Server Function The server function, the 2nd part of your Shiny application after the UI, is where most of your computation takes place. It is in the server function where you will use the values users inputted via the control widgets to do things like wrangle your data and create outputs like plots. These outputs will be saved to a special object called output which you can later reference in your UI in order to display them in your Shiny application. In the example below, we created a text output using the textRender function, saved it to the object output, and then displayed that output in our UI’s main panel using the function textOutput: # Example of a shiny application with a sidebar layout, selectInput control widget, # and simple text output. library(shiny) # Define UI ui &lt;- fluidPage( # Sidebar Layout sidebarLayout( # Sidebar Layout Elements (i.e. the panels) sidebarPanel = sidebarPanel( #Control Widget selectInput( inputId = &quot;input_1&quot;, label = &quot;Short description of control widget&quot;, choices = c( &quot;Iowa&quot; = &quot;IA&quot;, &quot;Colorado&quot; = &quot;CO&quot;, &quot;Massachusetts&quot; = &quot;MA&quot; ) ) ), mainPanel = mainPanel(textOutput(&quot;output_1&quot;)) )) # Server function server &lt;- function(input, output) { output$output_1 &lt;- renderText({ paste(&quot;You have selected&quot;, input$input_1) }) } # Run the application shinyApp(ui = ui, server = server) It is useful to remember the following 4 things when creating a new application output: In the server function, access user input values via the variable input$inputID In the server function, build your output (e.g. plot, table, text, etc.) using one of the render functions (i.e. renderPlot, renderDataTable, renderText, etc.), choosing the function that matches your output type. In the UI section, access your output via the variable output$output_name In the UI section, display your output using one of the corresponding *Output functions based on your output’s type (i.e. plotOutput, tableOutput, textOutput, etc.) "],
["shiny-reactivity-model.html", "4 Shiny Reactivity Model", " 4 Shiny Reactivity Model Most often, R developers will choose to create a Shiny application because they want their users to be able to interact with their data. In other words, the purpose of a Shiny application is that it reacts to the users’ interactions with it. To that end, it is helpful to understand the basics of how Shiny’s reactivity model works. What is reactive programming? Most commonly, R code is executed in a linear fashion from top to bottom. Line by line, the program is executed in the order that it was written. With reactive programming, the program also relies on events to determine how and when the code should be executed. Events are monitored and when they occur, the code reacts to those events. Why use render and output functions Shiny does not intuitively know which pieces of your code should be re-executed and at what times. When writing a Shiny app, you need to tell Shiny which chunks of your code should be reactive to events like users changing the input values in the control widgets. Because you want your plots, tables, and other outputs to be updated everytime a user changes the input, any expressions in your server section that depend on the input variable should be made reactive. To make a code chunk reactive, you can use one of Shiny’s many render functions which are reactive. For example, anything enclosed in the function renderPlot will be re-executed every time an event, such a changing input value, occurs: # Example of a Shiny server function # Define server logic required to draw a histogram server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on input$bins from ui.R x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } The above code, through the use of the reactive function renderPlot, will re-render the plot everytime a user interacts with the application. This new plot will be saved to the output variable, but it will not automatically update in the UI. To achieve this, you also need to make that code section in the UI reactive so it is updated whenever an event occurs. This can be done by using one of Shiny’s Output functions: # Define UI for application that draws a histogram ui &lt;- fluidPage( # Application title titlePanel(&quot;Old Faithful Geyser Data&quot;), # Sidebar with a slider input for number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) The UI code above will refresh the distribution plot displayed in the UI everytime a new plot is rendered in the server section. "],
["deploying-your-shiny-application.html", "5 Deploying Your Shiny Application", " 5 Deploying Your Shiny Application Now that you have created an application, the next step is choosing how this application will be shared with others. So far, we’ve only run the application on our local computers (or wherever your development environment is). In this section, we’ll take a look at the different locations you can deploy your application so it remains available 24/7 to anyone in the world who has been granted access to it. Deployment Options RStudio Connect is a publishing platform that can host many different types of data products created in R, including shiny applications. It offers features such such as push-button deployment and an API for more flexible deployment workflow. It is a paid software product which runs on a Linux server and is considered the de facto choice for enterprise environments. Shiny Server Open Source is a free alternative which also runs on Linux. Unlike RStudio Connect, it requires manual deployment of shiny applications, does not offer support for authentication integration with popular auth providers, cannot host other types of R data artifacts such as Plumber APIs and R Markdown documents, and is limited to a single R process. shinyapps.io is a shared hosting environment managed by RStudio. Both free and paid tiers are available. This hosting platform is most commonly used in non-enterprise environments. All of these hosting environments essentially act as typical web servers, except for the fact that they can also run a R Shiny process, which is required for running your Shiny application. "],
["optimizing-your-application.html", "6 Optimizing Your Application 6.1 RStudio Connect Infrastructure", " 6 Optimizing Your Application The goal is to have a Shiny application that loads quickly, is responsive, and can support whatever traffic is thrown at it without crashing. To achieve this, there are many available tools at your disposal. These include writing efficient code, pre-processing data ahead of time, and your infrastructure. 6.1 RStudio Connect Infrastructure In this section, we’ll look at some of the ways you can customize your infrastructure to improve the performance of your applications. 6.1.1 Runtime Settings As the publisher or collaborator of a Shiny application published on RStudio Connect, you have the ability to fine tune how your RStudio Connect server, or servers, should serve your application. These options can be set by editing the “Runtime” options found in the settings pane: "]
]
